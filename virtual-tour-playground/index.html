<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Virtual Playground</title>

  <!-- Babylon.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
  <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
  <script src="https://cdn.babylonjs.com/recast.js"></script>
  <script src="https://cdn.babylonjs.com/ammo.js"></script>
  <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  <script src="https://cdn.babylonjs.com/Oimo.js"></script>
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
  <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
  <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

  <style>
    html,
    body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #canvasZone {
      width: 100%;
      height: 100%;
    }

    #chatBox {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 400px;
      height: 400px;
      color: white;
      font-size: 20px;
      padding: 10px;
      box-sizing: border-box;
      background: red;
      display: flex;
      justify-content: space-between;
      flex-direction: column;
    }

    #form {
      background: rgba(0, 0, 0, 0.15);
      padding: 0.25rem;
      display: flex;
      height: 3rem;
      box-sizing: border-box;
      backdrop-filter: blur(10px);
    }

    #input {
      border: none;
      padding: 0 1rem;
      border-radius: 2rem;
      margin: 0.25rem;
      flex-grow: 1;
    }

    #input:focus {
      outline: none;
    }

    #form>button {
      background: #333;
      border: none;
      padding: 0 1rem;
      margin: 0.25rem;
      border-radius: 3px;
      outline: none;
      color: #fff;
    }

    #messages {
      list-style-type: none;
      margin: 0;
      padding: 0;
    }

    #messages>li {
      padding: 0.5rem 1rem;
    }

    #messages>li:nth-child(odd) {
      background: #efefef;
    }
  </style>
</head>

<body>
  <div id="chatBox">
    <ul id="messages"></ul>
    <form id="form" action="">
      <input id="input" autocomplete="off" /><button>Send</button>
    </form>
  </div>
  <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    var canvas = document.getElementById("renderCanvas");

    var startRenderLoop = function (engine, canvas) {
      engine.runRenderLoop(function () {
        if (sceneToRender && sceneToRender.activeCamera) {
          sceneToRender.render();
        }
      });
    };

    var engine = null;
    var scene = null;
    var sceneToRender = null;
    var createDefaultEngine = function () {
      return new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true,
        disableWebGL2Support: false,
      });
    };

    var createScene = function () {
      // Low Poly Character with Blender Tutorial of Grant Abbitt: https://www.youtube.com/user/mediagabbitt
      // Character animations by Mixamo: https://www.mixamo.com/

      engine.enableOfflineSupport = false;

      // Scene and Camera
      var scene = new BABYLON.Scene(engine);

      var camera1 = new BABYLON.ArcRotateCamera(
        "camera1",
        -Math.PI / 2,
        Math.PI / 4,
        2,
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      scene.activeCamera = camera1;
      scene.activeCamera.attachControl(canvas, true);
      camera1.lowerRadiusLimit = 2;
      camera1.upperRadiusLimit = 2;
      camera1.lowerBetaLimit = 0;
      camera1.wheelDeltaPercentage = 0.01;

      // Lights
      var light = new BABYLON.HemisphericLight(
        "light1",
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      light.intensity = 0.6;
      light.specular = BABYLON.Color3.Black();

      var light2 = new BABYLON.DirectionalLight(
        "dir01",
        new BABYLON.Vector3(0, -0.5, -1.0),
        scene
      );
      light2.position = new BABYLON.Vector3(0, 5, 5);

      // Skybox
      var skybox = BABYLON.MeshBuilder.CreateBox(
        "skyBox",
        { size: 1000.0 },
        scene
      );
      var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
      skyboxMaterial.backFaceCulling = false;
      skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
        "https://assets.babylonjs.com/skyboxes/skybox/skybox",
        scene
      );
      skyboxMaterial.reflectionTexture.coordinatesMode =
        BABYLON.Texture.SKYBOX_MODE;
      skyboxMaterial.diffuseColor = BABYLON.Color3.Black();
      skyboxMaterial.specularColor = BABYLON.Color3.Black();
      skybox.material = skyboxMaterial;

      // GUI
      var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(
        "UI"
      );
      var instructions = new BABYLON.GUI.TextBlock();
      instructions.text =
        "Move w/ WASD keys, B for Samba, look with the mouse";
      instructions.color = "white";
      instructions.fontSize = 16;
      instructions.textHorizontalAlignment =
        BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
      instructions.textVerticalAlignment =
        BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
      advancedTexture.addControl(instructions);

      // Ground
      // var ground = BABYLON.MeshBuilder.CreateGround(
      //   "ground",
      //   { height: 50, width: 50, subdivisions: 4 },
      //   scene
      // );
      // var groundNormalMap = new BABYLON.Texture("https://assets.babylonjs.com/textures/normalMap.jpg", scene);
      // var groundMaterial = new BABYLON.StandardMaterial(
      //   "groundMaterial",
      //   scene
      // );
      // groundMaterial.diffuseTexture = new BABYLON.Texture(
      //   "https://assets.babylonjs.com/textures/floor.png",
      //   scene
      // );
      // groundMaterial.diffuseTexture.uScale = 30;
      // groundMaterial.diffuseTexture.vScale = 30;
      // groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
      // ground.material = groundMaterial;

      // Keyboard events
      var inputMap = {};
      scene.actionManager = new BABYLON.ActionManager(scene);
      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnKeyDownTrigger,
          function (evt) {
            inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
          }
        )
      );
      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnKeyUpTrigger,
          function (evt) {
            inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
          }
        )
      );

      // Create a cube obstacle
      // const box = new BABYLON.MeshBuilder.CreateBox("crate", {size: 2}, scene);
      // box.material = new BABYLON.StandardMaterial("Mat", scene);
      // box.material.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/wood.jpg", scene);
      // box.checkCollisions = true;
      // box.position = new BABYLON.Vector3(0, 1, 10.0);

      BABYLON.SceneLoader.ImportMesh(
        "",
        "https://res.cloudinary.com/dnreuckfs/image/upload/v1699084059/",
        "s5aloz3a3ior2ubfv9nv.glb",
        scene,
        function (newMeshes, particleSystems, skeletons, animationGroups) {
          // hero1 = newMeshes[0];

          // //Scale the model down
          // hero1.scaling.scaleInPlace(0.1);

          //Position the character
          // hero1.position = new BABYLON.Vector3(4, 0, 0);
          const landscape = newMeshes[0];
          landscape.position = new BABYLON.Vector3(0, -4, 0);
          landscape.scaling.scaleInPlace(4)
        }
      );

      var headref
      BABYLON.SceneLoader.ImportMesh(
        "",
        "https://assets.babylonjs.com/meshes/",
        "box.glb",
        scene,
        function (newMeshes, particleSystems, skeletons, animationGroups) {
          headref = newMeshes[0];
          headref.position = new BABYLON.Vector3(0, 2, 0);
          headref.scaling.scaleInPlace(0.1);
          headref.setEnabled(false)

          camera1.target = headref;

          scene.onBeforeRenderObservable.add(() => {
            var keydown = false;
            var headrefSpeed = 0.03;
            var headrefSpeedBackwards = 0.01;
            var headrefRotationSpeed = 0.1;
            //Manage the movements of the character (e.g. position, direction)
            if (inputMap["w"]) {
              headref.moveWithCollisions(
                headref.forward.scaleInPlace(headrefSpeed)
              );
              keydown = true;
            }
            if (inputMap["s"]) {
              headref.moveWithCollisions(
                headref.forward.scaleInPlace(-headrefSpeedBackwards)
              );
              keydown = true;
            }
            if (inputMap["a"]) {
              headref.rotate(BABYLON.Vector3.Up(), -headrefRotationSpeed);
              keydown = true;
            }
            if (inputMap["d"]) {
              headref.rotate(BABYLON.Vector3.Up(), headrefRotationSpeed);
              keydown = true;
            }
          });
        }
      );

      var hero1;
      // Load hero character
      BABYLON.SceneLoader.ImportMesh(
        "",
        "https://assets.babylonjs.com/meshes/",
        "HVGirl.glb",
        scene,
        function (newMeshes, particleSystems, skeletons, animationGroups) {
          hero1 = newMeshes[0];

          //Scale the model down
          hero1.scaling.scaleInPlace(0.1);

          //Position the character
          // hero1.position = new BABYLON.Vector3(4, 0, 0);

          //Lock camera on the character
          // camera1.target = headref;

          //hero1 character variables
          var hero1Speed = 0.03;
          var hero1SpeedBackwards = 0.01;
          var hero1RotationSpeed = 0.1;

          const headDiam = 0.1;
          const bodyDiam = 0.01;
          const extra = 0.25;
          hero1.ellipsoid = new BABYLON.Vector3(0.5 * bodyDiam, 0.5 * (headDiam + bodyDiam), 0.5 * bodyDiam);
          hero1.ellipsoid.addInPlace(new BABYLON.Vector3(extra, extra, extra));
          const offsetY = 0.5 * (headDiam + bodyDiam) - hero1.position.y
          hero1.ellipsoidOffset = new BABYLON.Vector3(0, offsetY, 0);

          var animating = true;

          const walkAnim = scene.getAnimationGroupByName("Walking");
          const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
          const idleAnim = scene.getAnimationGroupByName("Idle");
          const sambaAnim = scene.getAnimationGroupByName("Samba");

          //Rendering loop (executed for everyframe)
          scene.onBeforeRenderObservable.add(() => {
            var keydown = false;
            //Manage the movements of the character (e.g. position, direction)
            if (inputMap["w"]) {
              hero1.moveWithCollisions(
                hero1.forward.scaleInPlace(hero1Speed)
              );
              keydown = true;
            }
            if (inputMap["s"]) {
              hero1.moveWithCollisions(
                hero1.forward.scaleInPlace(-hero1SpeedBackwards)
              );
              keydown = true;
            }
            if (inputMap["a"]) {
              hero1.rotate(BABYLON.Vector3.Up(), -hero1RotationSpeed);
              keydown = true;
            }
            if (inputMap["d"]) {
              hero1.rotate(BABYLON.Vector3.Up(), hero1RotationSpeed);
              keydown = true;
            }
            if (inputMap["b"]) {
              keydown = true;
            }

            //Manage animations to be played
            if (keydown) {
              if (!animating) {
                animating = true;
                if (inputMap["s"]) {
                  //Walk backwards
                  walkBackAnim.start(
                    true,
                    1.0,
                    walkBackAnim.from,
                    walkBackAnim.to,
                    false
                  );
                } else if (inputMap["b"]) {
                  //Samba!
                  sambaAnim.start(
                    true,
                    1.0,
                    sambaAnim.from,
                    sambaAnim.to,
                    false
                  );
                } else {
                  //Walk
                  walkAnim.start(
                    true,
                    1.0,
                    walkAnim.from,
                    walkAnim.to,
                    false
                  );
                }
              }
            } else {
              if (animating) {
                //Default animation is idle when no key is down
                idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                //Stop all animations besides Idle Anim when no key is down
                sambaAnim.stop();
                walkAnim.stop();
                walkBackAnim.stop();

                //Ensure animation are played only once per rendering loop
                animating = false;
              }
            }
          });
        }
      );

      var lastPrintTime = 0;
      scene.onBeforeRenderObservable.add(() => {
        if (hero1 && headref) {
          var currentTime = Date.now();
          if (currentTime - lastPrintTime >= 500) {
            // console.log(hero1.position, hero1.rotation);
            // console.log(camera1.position)
            lastPrintTime = currentTime;
          }
        }
        // if(camera1 && camera1.position.y < 0) camera1.position.y = 0;
      });

      return scene;
    };
    window.initFunction = async function () {
      var asyncEngineCreation = async function () {
        try {
          return createDefaultEngine();
        } catch (e) {
          console.log(
            "the available createEngine function failed. Creating the default engine instead"
          );
          return createDefaultEngine();
        }
      };

      window.engine = await asyncEngineCreation();
      if (!engine) throw "engine should not be null.";
      startRenderLoop(engine, canvas);
      window.scene = createScene();
    };
    initFunction().then(() => {
      sceneToRender = scene;
    });

    // Resize
    window.addEventListener("resize", function () {
      engine.resize();
    });

    const socket = io();

    const form = document.getElementById('form');
    const input = document.getElementById('input');
    const messages = document.getElementById('messages');

    form.addEventListener('submit', (e) => {
      console.log("here")
      e.preventDefault();
      if (input.value) {
        socket.emit('chat message', input.value);
        input.value = '';
      }
    });

    socket.on('chat message', (msg) => {
      const item = document.createElement('li');
      item.textContent = msg;
      messages.appendChild(item);
      window.scrollTo(0, document.body.scrollHeight);
    });
  </script>
</body>

</html>